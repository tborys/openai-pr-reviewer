import * as core from '@actions/core';
import { OpenAIReviewer, ReviewConfig } from './openai/client';
import { GitHubPRAnalyzer } from './github/context';

async function run(): Promise<void> {
  try {
    // Get inputs from GitHub Action
    const openaiApiKey = core.getInput('openai_api_key', { required: true });
    const githubToken = core.getInput('github_token', { required: true });
    const model = core.getInput('model') || 'gpt-4o';
    const reviewType = core.getInput('review_type') as ReviewConfig['reviewType'] || 'comprehensive';
    const maxFiles = parseInt(core.getInput('max_files') || '10', 10);
    const excludePatterns = core.getInput('exclude_patterns')
      .split(',')
      .map(pattern => pattern.trim())
      .filter(pattern => pattern.length > 0);
    const maxTokens = parseInt(core.getInput('max_tokens') || '4000', 10);

    core.info(`Starting OpenAI PR Review with model: ${model}, type: ${reviewType}`);

    // Configure OpenAI reviewer
    const reviewConfig: ReviewConfig = {
      model,
      maxTokens,
      temperature: 0.1,
      reviewType,
    };

    const reviewer = new OpenAIReviewer(openaiApiKey, reviewConfig);

    // Test OpenAI connection
    core.info('Testing OpenAI connection...');
    const connectionTest = await reviewer.testConnection();
    if (!connectionTest) {
      throw new Error('Failed to connect to OpenAI API');
    }
    core.info('OpenAI connection successful');

    // Initialize GitHub analyzer
    const githubAnalyzer = GitHubPRAnalyzer.fromContext(githubToken);

    // Check if we've already reviewed this PR
    const existingReview = await githubAnalyzer.checkExistingReviews();
    if (existingReview) {
      core.info('PR already has an OpenAI review, skipping...');
      return;
    }

    // Get PR context
    core.info('Fetching PR context...');
    const prContext = await githubAnalyzer.getPRContext(maxFiles, excludePatterns);
    
    core.info(`Found ${prContext.files.length} files to review`);
    prContext.files.forEach(file => {
      core.info(`- ${file.filename} (+${file.additions}/-${file.deletions})`);
    });

    if (prContext.files.length === 0) {
      core.info('No files to review (all files excluded or no changes)');
      await githubAnalyzer.postComment('ðŸ¤– **OpenAI PR Review**\n\nNo files to review based on the current filters and exclusions.');
      return;
    }

    // Generate review
    core.info('Generating AI review...');
    const review = await reviewer.reviewPR(prContext);

    // Format and post review
    const formattedReview = formatReview(review, reviewConfig, prContext.files.length);
    
    core.info('Posting review to GitHub...');
    await githubAnalyzer.postComment(formattedReview);

    core.info('âœ… PR review completed successfully');

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    core.error(`PR review failed: ${errorMessage}`);
    core.setFailed(errorMessage);
  }
}

function formatReview(review: string, config: ReviewConfig, fileCount: number): string {
  const timestamp = new Date().toISOString();
  
  return `## ðŸ¤– OpenAI PR Review

**Model**: ${config.model}  
**Review Type**: ${config.reviewType}  
**Files Reviewed**: ${fileCount}  
**Generated**: ${timestamp}

---

${review}

---

<sub>Generated by [OpenAI PR Reviewer](https://github.com/tborys/openai-pr-reviewer) â€¢ AI-powered code review</sub>`;
}

function validateInputs(): void {
  const requiredInputs = ['openai_api_key', 'github_token'];
  
  for (const input of requiredInputs) {
    if (!core.getInput(input)) {
      throw new Error(`Missing required input: ${input}`);
    }
  }

  const model = core.getInput('model') || 'gpt-4o';
  const supportedModels = ['gpt-4', 'gpt-4o', 'gpt-4-turbo', 'gpt-3.5-turbo'];
  
  if (!supportedModels.includes(model)) {
    core.warning(`Unsupported model: ${model}. Supported models: ${supportedModels.join(', ')}`);
  }

  const reviewType = core.getInput('review_type') || 'comprehensive';
  const supportedTypes = ['comprehensive', 'security', 'performance', 'style'];
  
  if (!supportedTypes.includes(reviewType)) {
    throw new Error(`Unsupported review type: ${reviewType}. Supported types: ${supportedTypes.join(', ')}`);
  }
}

// Run the action
if (require.main === module) {
  run();
}

export { run };